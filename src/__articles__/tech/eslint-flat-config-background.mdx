# ESLint's flat config: Background

이 글에서는 **ESLint 설정 시스템의 발전 과정과 최신 설정 방식인 [Flat Config의 탄생 배경](https://eslint.org/blog/2022/08/new-config-system-part-1/)에 대해 다룹니다.**

## 목차
0. 개요
1. 초기 ESLint 설정 시스템과 "Config Cascade" (2013)
2. extends key (2014)
3. 개인 설정 (\~/.eslintrc) 지원 (2015)
4. root: true 속성 추가 (2016)
5. overrides key (2018)
6. extends를 overrides 내부에서 지원 (2019)
7. ESLint 설정 복잡성의 증가와 새로운 설정 시스템 제안 (2019)
8. Flat Config 도입 (2022)

## 0. 개요
하나의 프로젝트가 마치 한 사람이 작성한 코드처럼 보인다면, 그만큼 코드 스타일이 일관되며 개발자들이 같은 원칙을 공유하고 있다는 의미가 됩니다.
물론 한 사람이 작성하더라도 코드 스타일이 달라질 수 있지만, 전체적으로 통일된 스타일을 유지하는 것은 협업에서 중요한 요소입니다.

현재 백오피스를 개발하면서, 지난 몇 년간 작성된 코드를 분석하고 수정하며 새로운 기능을 추가하는 작업을 하고 있습니다.
방대한 코드 베이스를 보면서 코드 스타일이 파일마다 제각각인 문제를 발견했습니다. 예를 들면:
- React Hooks 선언 순서가 뒤죽박죽인 경우
- 어떤 파일에서는 import만 사용하고, 어떤 파일에서는 import type을 사용하는 경우
- 한 줄 return 시 \{\} 사용 여부

이처럼 일관되지 않은 코드 스타일은 유지보수를 어렵게 만들고, 새로운 개발자가 적응하는 데 걸리는 시간을 증가시킵니다. (~~어느 장단에 맞춰야 해!!!~~)
프로젝트 초기에 [ESLint](https://eslint.org/)와 [Prettier](https://prettier.io/)와 같은 도구를 엄격하게 설정했다면 이런 문제를 줄일 수 있었겠지만, 
현재 상황은 그렇지 않았습니다.

이 문제를 고민하던 중, 한 동료 개발자가 과거 경험을 공유해주었습니다. "변수를 타입 순서로, 알파벳 순서로 정리하고 있으며 **첫 코드 리뷰 당시 코드 스타일 문제로 첫 커밋에서 7번이나 리젝 당한 경험이 있다**"는 것이었습니다.
이 이야기를 들으면서, 기존 코드 스타일을 정리하고 일관되게 맞춰둔다면 앞으로 프로젝트에 합류하는 개발자들이 같은 문제로 혼란을 겪지 않을 것이라는 생각이 들었습니다. 
결과적으로 코드 이해도가 높이지고, 적응 속도가 빨라지며, 코드의 의도도 더욱 명확해질 것이라고 생각이 들었습니다.

이러한 문제를 해결하기 위해 ESLint를 적극적으로 활용하는 것이 좋겠다고 판단했습니다. ESLint는 프로젝트 전반의 코드 스타일을 통일할 수 있도록 도와주며, 협업을 더욱 원활하게 만들어 줍니다.
어떤 규칙을 적용할 지 고민하는 과정에서, 프론트엔드 개발자들이 공통적으로 사용할 수 있는 설정 파일을 만들어 공유한다면, 팀 내에서뿐만 아니라 다른 프로젝트에서도 일관된 코드 스타일을 유지할 수 있을 것이라고 생각했습니다.

## 1. 초기 ESLint 설정 시스템과 "Config Cascade" (2013)
2013년 초기 ESLint 설정 시스템은 매우 단순한 형태로 시작했습니다.
- .eslintrc 파일을 만들어 규칙을 직접 정의하면 되었습니다.
- 현재 디렉토리에서 .eslintrc 파일을 찾고, 없으면 부모 디렉토리로 올라가면서 추가 설정을 병합하는 방식\(=**Config Cascade**\)를 사용했습니다,
- JSHint와 같은 기존 Linter에서는 디렉토리별 설정이 불가능했지만, ESLint는 Config Cascade를 통해 이를 가능하게 했습니다.

예를 들면: 아래와 같이 각각의 디렉토리에 .eslintrc를 넣어 설정이 가능했습니다.
```typescript
/home/user/project/
 ├── .eslintrc (1)
 ├── src/
 │    ├── .eslintrc (2)
 │    ├── index.js
 │    ├── utils.js
```

**Config Cascade**는 디렉토리마다 설정을 다르게 할 수 있다는 장점이 있었습니다.
예를 들어, 특정 폴더에만 별도의 규칙을 적용하거나, 폴더별로 다른 설정이 필요한 경우 효과적이었습니다.
또한, 상위 디렉토리의 설정을 자동으로 물려받기 때문에 설정을 전체적으로 관리하기가 편리했습니다.

하지만 이런 방식은 단점도 있었습니다. 우선, 상위 디렉토리에 숨겨진 설정이 나도 모르게 적용될 수 있어서 혼란을 주곤 했습니다.
예를 들어, 프로젝트 바깥에 `.eslintrc` 파일이 있으면 예상치 못한 규칙이 적용돼서 내가 설정한 적 없는 규칙 때문에 당황하는 경우가 종종 발생했습니다.
또한, 복잡한 프로젝트에서는 여러 설정 파일이 서로 충돌하는 문제가 발생해, 특정 파일에 정확히 어떤 설정이 적용되는지 쉽게 예측하기 어려웠습니다. 마지막으로, 전역 설정을 방지하는 게 까다로웠습니다.
개인이 만든 설정 파일(예: `~/.eslintrc`)이 팀 프로젝트에 자동으로 적용되어 의도치 않은 설정이 섞이는 문제도 있었습니다.

## 2. extends key (2014)
2014년에는 프로젝트 간의 설정을 공유하기 위해서 **extends** key가 추가되었습니다.
- extends key를 사용하여 다른 설정을 가져와서 확장할 수 있도록 개선되었습니다.
- 결과적으로 eslint-config-\* 개념(**Shareable Configs**)이 탄생하는 계기가 되었습니다. 

아래와 같은 방식으로 정의가 가능해졌습니다.
```typescript
{
  "extends": ["eslint:recommended"],
  "rules": {
    "semi": ["error", "always"]
  }
}
```

`extends` 키워드가 도입되면서 ESLint 설정을 서로 공유하고 재사용할 수 있게 되었습니다. 
이를 통해 팀 단위나 프로젝트 간에 설정을 복사하지 않고도 간단하게 공유된 설정을 가져다 사용할 수 있었습니다. 
예를 들어, Airbnb 스타일 가이드나 Prettier와 같은 널리 사용되는 설정을 손쉽게 적용할 수 있었습니다.
덕분에 팀이나 프로젝트마다 일관된 규칙을 적용하는 것이 편리해졌고, 필요에 따라 프로젝트별로 조금씩 다른 설정을 구성할 수 있는 유연성도 생겼습니다.

하지만 장점과 동시에 새로운 문제가 생겨났습니다. 
extends가 기존의 Config Cascade와 일부 기능이 겹치면서 설정 구조가 혼란스러워지기도 했습니다. 
설정을 계층적으로 관리할 수 있는 extends 기능이 기존의 Config Cascade와 함께 사용될 경우, 어떤 설정이 최종적으로 적용되는지 직관적으로 파악하기 어려워졌습니다. 
또한, 여러 개의 설정을 extends로 가져올 때 서로 충돌하는 경우가 자주 발생해 관리가 복잡해지는 문제점도 있었습니다.

## 3. 개인 설정 (\~/.eslintrc) 지원 (2015)
2015년에는 사용자가 자신만의 ESLint 설정을 홈 디렉토리 (\~/.eslintrc)에 저장할 수 있도록 지원했습니다.

개인의 홈 디렉터리에 설정을 저장할 수 있는 `~/.eslintrc` 파일은 자신의 모든 프로젝트에 공통적으로 적용할 규칙을 설정할 수 있다는 장점이 있었습니다. 
덕분에 매번 새 프로젝트를 시작할 때마다 설정 파일을 따로 만들 필요 없이, 개인이 선호하는 규칙을 간편하게 유지할 수 있었습니다.

하지만 이 방식은 단점도 있었습니다. 
특히 프로젝트 폴더 내에 별도의 설정 파일이 없으면 ESLint는 자동으로 개인 설정(`~/.eslintrc`)을 적용했기 때문에, 내가 의도하지 않은 규칙이 적용되는 일이 발생했습니다. 
이로 인해 다른 팀원이 프로젝트를 실행했을 때 각자 다른 결과가 나오거나, 개발자가 자신의 개인 설정이 적용되고 있다는 사실조차 모르고 혼란을 겪는 경우도 있었습니다. 
결국, 설정이 명확하지 않아 협업 환경에서 예상치 못한 문제가 자주 일어나곤 했습니다.

## 4. root: true 속성 추가 (2016)
2016년에는 Config Cascade가 예기치 않게 동작하는 문제를 해결하기 위해 **root: true 속성**이 추가되었습니다.
이를 통해 상위 디렉토리 설정이 적용되지 않도록 강제하고, 예상치 못한 설정 충돌을 방지할 수 있게 되었습니다. 예를 들어:

``` typescript
{
  "root": true,
  "extends": "eslint:recommended",
  "rules": {
    "semi": ["error", "always"]
  }
}
```

## 5. overrides key (2018)
2018년에는 overrides key가 추가됨으로써 파일별로 다른 규칙을 적용할 수 있게 되었습니다.
특정 패턴의 파일\(ex., 테스트 파일, 빌드 스크립트)에는 다른 규칙을 적용할 수 있게 된 것입니다. 예를 들어:

```typescript
{
  "rules": {
    "quotes": ["error", "double"]
  },
  "overrides": [
    {
      "files": ["*.test.js"],
      "rules": {
        "quotes": ["error", "single"]
      }
    }
  ]
}
```


## 6. extends를 overrides 내부에서 지원 (2019)
overrides는 특정 파일 패턴에 따라 설정을 변경할 수 있지만, 여전히 설정을 extends할 수는 없었습니다.
2019년에는 이러한 문제를 해결하기 위해 overrides 내부에서도 extends를 사용할 수 있도록 기능을 확장했습니다.
이제 특정 파일 패턴에 대해 기존 공유 설정을 그대로 가져와 적용할 수 있게 되었습니다. 예를 들어:

```typescript
{
  "rules": {
    "quotes": ["error", "double"]
  },

  "overrides": [
    {
      "files": ["bin/*.js", "lib/*.js"],
      "excludedFiles": "*.test.js",
      "extends": ["eslint:recommended"],
      "rules": {
        "quotes": ["error", "single"]
      }
    }
  ]
}
```

`overrides` 내부에서도 `extends`를 지원하게 되면서 ESLint는 특정 파일 패턴에 대해서도 기존의 공유된 설정을 쉽게 확장해 적용할 수 있게 되었습니다. 
덕분에 프로젝트 전체에 적용되는 기본 규칙과 특정 패턴(예: 테스트 파일, 설정 파일 등)의 개별 규칙을 더 쉽게 조합하여 사용할 수 있게 된 것입니다.

하지만 이 기능의 추가는 설정의 복잡성을 증가시키는 원인이 되기도 했습니다. 
설정이 계층적으로 여러 번 중첩될 수 있게 되면서, 글로벌 설정과 지역 설정이 어떤 방식으로 병합되는지 예측하기가 어려워졌습니다. 
특히 extends한 설정 자체에 다시 overrides가 포함된 경우, 최종적으로 어떤 규칙이 적용되는지 파악하기가 매우 복잡해졌습니다. 
또한, 파일 패턴(glob 패턴)이 여러 설정 간에 중첩될 경우 최종적으로 어떤 파일이 어떤 규칙을 따르게 되는지 직관적으로 알기 어려워 개발자들에게 혼란을 주었습니다.

## 7. ESLint 설정 복잡성의 증가와 새로운 설정 시스템 제안 (2019)
이 시점에서 **ESLint 설정 시스템이 과도한 기능 추가로 유지보수가 어려운 상태가 되었습니다.**
- 너무 많은 설정 방식이 존재하게 되었습니다.(Config Cascade, extends, overrides, root, .eslintrc.json, ...)
- extends와 overrides 조합으로 인해 규칙 병합이 예상하기 어려워졌습니다.
- 팀 내에서도 설정 시스템을 수정하는 것이 부담스러워질 정도로 복잡해졌습니다.

ESLint 팀은 이 문제를 해결하기 위해 기존 .eslintrc를 버리고 새로운 설정 시스템을 만들지 고민하였습니다.
이는 팀 내부에서도 "완전히 새롭게 설계" vs "기존 시스템을 개선"으로 의견이 갈렸고 18개월의 논의 끝에 **기존 시스템을 버리고 새로운 설정 시스템**을 만들기로 결정했습니다.
이 설정 시스템이 **Flat Config**입니다.

## 8. Flat Config 도입 (2022)
기존 .eslintrc 설정 방식의 복잡성을 해결하기 위해 ESLint v8.21.0에서 새로운 **Flat Config 시스템**을 도입하게 되었습니다.
.eslintrc의 overrides, extends, root: true와 같은 개념을 한 곳에 통합하고 files 배열로 파일 패턴을 지정하여 특정 규칙을 적용 가능하게 만들며 기존 ESLint 설정 방식과 유사하면서도 단순화된 설정 구조를 제공하였습니다. 
예를 들어: 아래와 같이 정의할 수 있게 되었습니다.


```typescript
export default [
  {
    files: ["**/*.js"],
    rules: {
      quotes: ["error", "double"],
      semi: ["error", "always"]
    }
  },
  {
    files: ["tests/**/*.js"],
    rules: {
      quotes: ["error", "single"]
    }
  }
];
```

## 마치며
이번 기회를 통해 ESLint가 어떻게 발전해왔고, 앞으로 어떤 방향으로 나아갈지에 대해 알게 되었습니다. 
개발을 시작한 초기부터 ESLint를 꾸준히 사용해왔지만, **그동안의 변화와 개선 과정에 이런 역사가 있었는지는 처음 알게 되었습니다**. 

글을 읽으면서 **Flat Config가 단순히 설정 방식을 단순화하기 위한 것인지, 성능적인 관점에서도 고려된 변화인지 궁금해졌습니다**. 
다음 글에서는 Flat Config에 대해서 더 자세하게 다룹니다.


## References
- [ESLint's new config system, Part1: Background](https://eslint.org/blog/2022/08/new-config-system-part-1/)
- [ESLint's new config system, Part2: Introduction to flat config](https://eslint.org/blog/2022/08/new-config-system-part-2/)
- [ESLint's new config system, Part3: Developer preview](https://eslint.org/blog/2022/08/new-config-system-part-3/)