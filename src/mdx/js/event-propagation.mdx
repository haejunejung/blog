import DOM from "./assets/DOM.png"

# 이벤트 전파(Event Propagation)
브라우저가 이벤트를 처리하는 방식, 이벤트 전파에 대해 공부한 글입니다.

React는 합성 이벤트(Synthetic Event)와 이벤트 위임(Event Delegation)이라는 두 가지 매커니즘을 활용해
개발자가 이벤트 처리 과정을 직접 관리하지 않아도 되도록 합니다. 이를 통해 이벤트 전파의 복잡성을 
대부분 내부적으로 해결하며, 개발자는 보다 직관적이고 간단하게 이벤트를 다룰 수 있습니다.

React로 웹 개발을 시작한 저는 이벤트 전파 방식에 대해 자세히 알지 못한 채로 프로젝트를 진행했습니다.
컴포넌트 수준에서 onClick, onChange와 같은 핸들러를 사용하는 것만으로도 충분하다고 생각했기 때문입니다.
하지만 이벤트가 "왜" 그리고 "어떻게" 발생하는지 이해할 필요가 있다고 느껴져 이번 기회에 
DOM과 이벤트 전파 방식에 대해 공부하게 되었습니다.

## DOM
이벤트 전파에 대해 알기 위해서는 DOM의 기본적인 구조에 대해 알 필요가 있습니다.

DOM(Document Object Model)은 HTML 문서의 구조를 트리 형태로 표현한 객체 모델입니다.
브라우저는 이 모델을 통해 웹페이지를 화면에 렌더링하고, JavaScript와 상호작용할 수 있도록 만듭니다.

<img src={DOM} alt="Document Object Model" style={{ width: "100%" }} />

예를 들어, 다음과 같은 코드가 있습니다.
```html
<div>
    <button>Click Me!</button>
</div>
```

이 구조는 DOM 트리에서 다음과 같이 표현됩니다.
```css
Document
└── <html>
    └── <body>
        └── <div>
            └── <button>
```

이처럼 DOM의 각 엘리먼트들은 태그 안에 태그가 위치하는 방식으로 **계층적**으로 이루어져 있습니다.

## 이벤트 전파
DOM의 계층적 구조 특징 때문에 만일 HTML 요소에 이벤트가 발생할 경우, 연쇄적인 이벤트 흐름이 일어나게 됩니다.

예를 들어, 다음과 같이 section -> div -> button으로 HTML 구조를 만들어낸 후, 각각의 onclick 핸들러를 
생성하고 button을 클릭해봅시다.
```html
<section onclick="alert('section'))">section
    <div onclick="alert('div')">div
        <button onclick="alert('button')">button</button>
    </div>
</section>
```

button 하나만 눌러도, button -> div -> section 순으로 이벤트가 발생하는 것을 볼 수 있습니다.
이러한 현상을 이벤트 전파라고 부르며, 전파 방향에 따라 캡처링과 버블링으로 구분합니다.

- 캡처링(Capturing): 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 안쪽 자식 요소까지 도달하는 것
- 버블링(Bubbling): 자식 요소에서 발생한 이벤트가 바깥 부모 요소로 전파되는 것 (기본값)

브라우저는 이벤트 캡처링과 버블링을 활용해 이벤트의 흐름을 만들어내고 있습니다.
이벤트 흐름을 자세히 살펴보면, 캡처링 -> 타겟 -> 버블링 순으로 만들어집니다.

즉, 이벤트가 발생하면 가장 상단의 요소부터 하위의 요소까지 내려오고 다시 거슬러 올라가는 방식으로
이벤트를 전달하여 발생하도록 합니다. 만일 타겟 요소까지 이벤트를 전파하는 과정에서 그의 부모,
조상에도 이벤트 리스너가 등록되어 있다면 버블링 과정에서 이 이벤트를 실행하게 됩니다.

## 이벤트 전파가 있는 이유

1. 자식 요소가 부모 요소 영역 안에 위치하고 있기 때문에 자식 요소만을 클릭하였다 하더라도,
다른 시각으로 보면 부모 요소도 클릭한 셈이기 때문이다. 

2. 성능적인 이유: 여러 개의 아이템을 가진 리스트가 있을 때, 몇 번째 리스트를 클릭하든 이벤트를 
발생시키고 싶은 사례들에서 유용하게 사용할 수 있다.

```html
<ul onclick="alert('item')">
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
    <li>Item 4</li>
    <li>Item 5</li>
    <li>Item 6</li>
</ul>
```

만약 이벤트 전파 개념이 없다면 li 요소마다 일일이 이벤트를 등록해야 하는 노가다가 필요할 지도 모른다.
하지만 버블링의 특성을 통해 우리는 부모 요소인 ul 요소에만 이벤트를 등록하면 몇 번째의 li 요소를 클릭하더라도
부모 요소로 이벤트가 전파되기 때문에 원하는 구현을 간단하게 할 수 있다. 이러한 기법을 이벤트 위임이라 한다.

### 이벤트 전파 제어
떄때로 부모와 자식 둘다 이벤트가 등록되어 있는 상황에서, 자식 요소만 클릭했을 때만 이벤트를
발생시키고 부모 요소는 이벤트를 발생시키고 싶지 않은 상황이 있다.
하지만 브라우저는 기본적으로 캡처링 -> 타겟 -> 버블링으로 동작되기 때문에 이벤트 동작 자체를 
변경할 수는 없다. 따라서 엘리먼트의 이벤트 전파를 방지하는 방식으로 처리해야 한다.

e.stopPropagation 메서드를 호출하면 버블링 또는 캡처링 설정에 따라 상위, 하위로 가는 이벤트 
전파를 막을 수 있다.

e.stopImmediatePropagation 메서드를 호출하면 이벤트 전파와 더불어 형제 이벤트 실행을 중지한다.
예를 들어, 하나의 요소에 두 개의 이벤트 리스너가 등록되어 있을 때, 어떠한 조건에서 
클릭 이벤트를 두 번 실행하지 않고 한 번만 실행하기를 원할 때 사용할 수 있다.

e.target으로 조건을 걸어 방지할 수도 있다. e.target은 실제 이벤트가 걸린 DOM 엘리먼트 객체이고,
그 안의 tagName, className, id 속성을 통해 태그의 정보를 분류할 수 있다. 
이 정보를 바탕으로 직접 조건 분기를 통해 일일이 지정해주는 방식으로 이벤트를 제어할 수 있다.

```javascript
document.body.addEventListener('click', (e) => {
    if (e.target.id === "ancestor") {}
    if (e.target.id === "parent") {}
    if (e.target.id === "child") {}
});
```

e.preventDefault는 이벤트의 전파뿐만 아니라 기본 이벤트 동작 자체를 취소한다.

### 이벤트 전파 방지 주의점
버블링 이벤트를 막는 메서드는 추후에 문제가 될 수 있는 상황을 만들어낼 수 있다.

예를 들어, window 내에서 발생하는 클릭 이벤트 전부를 감지하는 분석 시스템을 사용할 때,
이런 분석 시스템의 코드는 클릭 이벤트를 감지하기 위해 보통 document.addEventListener('click')을
사용하는데, 이벤트 버블링을 막아놓은 영역에서는 dead zone이 되어버려 분석이 이뤄지지 않을 수 있다.
따라서 꼭 필요한 경우에만 버블링을 막는 것이 옳다.