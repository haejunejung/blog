# React 1편 - React Lagacy 공식 문서
이 글은 React의 Legacy 공식 문서를 정독한 내용을 담고 있습니다.

글을 쓰는 현재는 React v19까지 발표되었습니다. 최신의 문법과 기능들을 사용하다보면 '왜?' 이 기능들이
생겨났는지 궁금해질 때가 많습니다. 이러한 궁금증을 해소하고자 과거의 React부터 최신의 React까지 
공부해보는 시간을 가져보기로 했습니다. React 시리즈는 다음과 같이 공부해보려 합니다.

**(1) React Lagacy 공식문서 👈**

(2) React 현재 공식문서

(3) React Release Note (v16 ~ v19)

## 주요 개념
React는 전통적인 탬플릿 기반의 접근 방식에서 **관심사의 분리**를 실현하기 위해 만들어졌습니다.
기존의 탬플릿 시스템은 HTML과 JavaScript를 결합하여 UI를 정의하지만, 기술적으로는 분리가 이루어졌을지 몰라도
실제로 관심사는 잘 분리되지 않은 경우가 많았습니다. 게다가 기능이 제한적이어서, JavaScript가
제공하는 기능을 다시 구현해야 하는 경우가 많았습니다.

**React는 컴포넌트를 통해 관심사의 분리를 실현합니다.** 각 컴포넌트는 UI의 작은 부분을 맡아
독립적으로 동작하고, 다른 컴포넌트와의 의존성을 최소화합니다. 즉, 컴포넌트 중심의 개발 방식을 통해
**결합도는 낮추고 응집도는 높이는** 효과를 얻을 수 있습니다. 이를 통해 코드는 더 깔끔하고 관리하기 편해집니다.

React의 렌더링 철학도 중요한 특징입니다. **React는 데이터가 변경될 때마다 UI를 전체적으로 다시 렌더링하는 
방식**을 채택하고 있습니다. 이렇게 하면 UI의 모든 부분이 항상 최신 데이터에 맞게 업데이트되므로
화면에 표시되는 내용이 항상 정확하고 일관되게 유지할 수 있습니다. 매번 전체 UI를 다시 그리는 방식이
비효율적일 수 있지만, React는 이를 해결하기 위해 **Virtual DOM**을 도입하여 성능을 최적화하고 있습니다.

[Reference: "React: Rethinking best practices"](https://www.youtube.com/watch?v=x7cQ3mrcKaY)

### JSX
JSX는 JavaScript Syntax eXtension의 약자로 JavaScript를 확장한 문법입니다.

React는 별도의 파일에 마크업과 로직을 넣어 기술을 인위적으로 분리하는 대신 "컴포넌트"라고 
불리는 느슨하게 연결된 유닛으로 관심사의 분리를 합니다. 이는 React에서 본질적으로 렌더링 로직이
UI 로직(이벤트가 처리되는 방식, 시간에 따라 state가 변하는 방식, 화면에 표시하기 위해 데이터가 준비되는 방식)과
연결된다는 사실을 받아들였기 때문입니다. 

이를 효과적으로 만들기 위해서 JSX 사용을 권장하고 있습니다. 

```javascript
// JSX를 사용할 때

const element = (
    <div className="App">
        <h1 className="title">안녕하세요. <span className="name">정해준입니다.</span></h1>
    </div>
)
```

```javascript
// React.createElement (Lagacy API)를 사용할 때
// React.createElement(type, props, ...children)

const element = React.createElement(
    'div', { className: "App" }, React.createElement(
        'h1', { className: "title" }, '안녕하세요', React.createElement(
            'span', { className: "name" }, '정해준입니다.'
        )
    )
)
```

<Callout type="note" title="JSX 문법의 특징">
1. 요소가 하나 이상이라면, 반드시 부모 요소로 감싸는 형태여야 합니다. 이는 Virtual DOM에서 컴포넌트 변화를 감지할 때
효율적으로 비교할 수 있도록 컴포넌트 내부에는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문입니다.

2. 브라우저에서 실행하기 전에 코드가 번들링되는 과정에서 바벨과 같은 트랜스파일러에 의해 
일반 자바스크립트 형태의 코드로 변환됩니다. (브라우저는 JSX를 바로 이해할 수 없어요!)
</Callout>

### Element와 Component
React에서 **Element는 UI를 구성하는 가장 작은 단위**입니다. 브라우저 DOM Element와는 다르게 
React Element는 일반 객체(Plain Object)로 표현되며, React는 이를 통해 DOM을 효율적으로 업데이트합니다.
React에서 **Component**는 여러 React Element를 결합하여 UI의 특정 부분을 **재사용 가능한 단위**로 만드는 데 사용됩니다.

React Element는 **불변 객체**라는 중요한 특징을 가지고 있습니다. 
```javascript
const element = <h1>Hello, World!</h1>
element.props.children = "Hi!"; // ❌ 변경 불가
```

React Element는 **특정 시점의 UI**를 나타냅니다. 데이터가 변경되면 React는 새로운 Element를 생성하여 UI를 업데이트합니다.
```javascript
const root = ReactDOM.createElement(document.getElementById('root'));

function tick() {
    const element = (
        <div>
            <h1>hello, world!</h1>
            <h2>It is {new Date().toLocaleTimeString()}</h2>
        </div>
    )

    root.render(element);
}

setInterval(tick, 1000); // 1초마다 하나의 프레임을 실행합니다.
```

위 코드를 보면 매초 새로운 React Element를 생성하고, 이를 root.render()를 통해 DOM에 렌더링합니다.
언뜻 보면 모든 요소를 다시 렌더링하는 것 같지만, React는 Virtual DOM을 사용해 
변경된 부분만 실제 DOM에 반영합니다. 개발자 도구에서 이 코드의 결과를 확인해보면, h1 태그의 내용은
변하지 않고 h2 태그의 시간 정보만 업데이트되는 것을 볼 수 있습니다.